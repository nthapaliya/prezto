# vim:ft=zsh ts=2 sw=2 sts=2

# Original prompt created by promptline.vim
# Hand tweaked and cleaned for zsh by Niraj Thapaliya
#
function __promptline_host {
  local only_if_ssh="0"

  if [ ! $only_if_ssh -o -n "${SSH_CLIENT}" ]; then
    if [[ -n ${ZSH_VERSION-} ]]; then print %m; elif [[ -n ${FISH_VERSION-} ]]; then hostname -s; else printf "%s" \\h; fi
  fi
}

function __promptline_last_exit_code {
  [[ $last_exit_code -gt 0 ]] || return 1;
  printf "%s" "$last_exit_code"
}

function __promptline_vcs_branch {
  local branch
  local branch_symbol=" "

  # git
  if hash git 2>/dev/null; then
    if branch=$( { git symbolic-ref --quiet HEAD || git rev-parse --short HEAD; } 2>/dev/null ); then
      branch=${branch##*/}
      printf "%s" "${branch_symbol}${branch:-unknown}"
      return
    fi
  fi
  return 1
}

function __promptline_cwd {
  local dir_limit="3"
  local truncation="⋯"
  local first_char
  local part_count=0
  local formatted_cwd=""
  local dir_sep="  "
  local tilde="~"

  local cwd="${PWD/#$HOME/$tilde}"

  # get first char of the path, i.e. tilde or slash
  first_char=$cwd[1,1]

  # remove leading tilde
  cwd="${cwd#\~}"

  while [[ "$cwd" == */* && "$cwd" != "/" ]]; do
    # pop off last part of cwd
    local part="${cwd##*/}"
    cwd="${cwd%/*}"

    formatted_cwd="$dir_sep$part$formatted_cwd"
    part_count=$((part_count+1))

    [[ $part_count -eq $dir_limit ]] && first_char="$truncation" && break
  done

  printf "%s" "$first_char$formatted_cwd"
}

function __promptline_wrapper {
  [[ -n "$1" ]] || return 1
  printf "%s" "${2}${1}${3}"
}

function __promptline_left_prompt {
  local slice_prefix slice_empty_prefix slice_joiner slice_suffix is_prompt_empty=1

  # section "a" header
  slice_prefix="${a_bg}${sep}${a_fg}${a_bg}${space}"
  slice_suffix="$space${a_sep_fg}"
  slice_joiner="${a_fg}${a_bg}${alt_sep}${space}"
  slice_empty_prefix="${a_fg}${a_bg}${space}"
  [ $is_prompt_empty -eq 1 ] && slice_prefix="$slice_empty_prefix"
  # section "a" slices
  __promptline_wrapper "$(__promptline_host)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; is_prompt_empty=0; }

  # section "b" header
  slice_prefix="${b_bg}${sep}${b_fg}${b_bg}${space}"
  slice_suffix="$space${b_sep_fg}"
  slice_joiner="${b_fg}${b_bg}${alt_sep}${space}"
  slice_empty_prefix="${b_fg}${b_bg}${space}"
  [ $is_prompt_empty -eq 1 ] && slice_prefix="$slice_empty_prefix"
  # section "b" slices
  __promptline_wrapper "$USER" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; is_prompt_empty=0; }

  # section "c" header
  slice_prefix="${c_bg}${sep}${c_fg}${c_bg}${space}"
  slice_suffix="$space${c_sep_fg}"
  slice_joiner="${c_fg}${c_bg}${alt_sep}${space}"
  slice_empty_prefix="${c_fg}${c_bg}${space}"
  [ $is_prompt_empty -eq 1 ] && slice_prefix="$slice_empty_prefix"
  # section "c" slices
  __promptline_wrapper "$(__promptline_cwd)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; is_prompt_empty=0; }

  # close sections
  printf "%s" "${reset_bg}${sep}$reset$space"
}

function __promptline_right_prompt {
  local slice_prefix slice_empty_prefix slice_joiner slice_suffix

  # section "warn" header
  slice_prefix="${warn_sep_fg}${rsep}${warn_fg}${warn_bg}${space}"
  slice_suffix="$space${warn_sep_fg}"
  slice_joiner="${warn_fg}${warn_bg}${alt_rsep}${space}"
  slice_empty_prefix=""
  # section "warn" slices
  __promptline_wrapper "$(__promptline_last_exit_code)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; }

  # section "y" header
  slice_prefix="${y_sep_fg}${rsep}${y_fg}${y_bg}${space}"
  slice_suffix="$space${y_sep_fg}"
  slice_joiner="${y_fg}${y_bg}${alt_rsep}${space}"
  slice_empty_prefix=""
  # section "y" slices
  __promptline_wrapper "$(__promptline_vcs_branch)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; }

  # close sections
  printf "%s" "$reset"
}

function __promptline {
  local last_exit_code="$?"

  local space=" "
  local sep=""
  local rsep=""
  local alt_sep=""
  local alt_rsep=""

  local a=(235 208)
  local b=(15 136)
  local c=(15 243)
  local warn=(235 208)
  local y=(15 239)

  local reset="%f" reset_bg="%k"
  local a_fg="%F{$a[1]}" a_bg="%F{$a[2]}" a_sep_fg="%F{$a[2]}"
  local b_fg="%F{$b[1]}" b_bg="%K{$b[2]}" b_sep_fg="%F{$b[2]}"
  local c_fg="%F{$c[1]}" c_bg="%K{$c[2]}" c_sep_fg="%F{$c[2]}"
  local warn_fg="%F{$warn[1]}" warn_bg="%K{$warn[2]}" warn_sep_fg="%F{$warn[2]}"
  local y_fg="%F{$y[1]}" y_bg="%K{$y[2]}" y_sep_fg="%F{$y[2]}"

  PROMPT="$(__promptline_left_prompt)"
  RPROMPT="$(__promptline_right_prompt)"
  SPROMPT='zsh: correct %F{red}%R%f to %F{green}%r%f [nyae]? '
}

function prompt_promptline_setup {
  prompt_opts=(cr percent subst)
  autoload -Uz add-zsh-hook
  add-zsh-hook precmd __promptline
}

prompt_promptline_setup
